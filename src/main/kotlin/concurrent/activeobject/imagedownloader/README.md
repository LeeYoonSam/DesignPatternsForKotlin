# Active Object Pattern

## 설명
Active Object 패턴은 메서드 호출과 메서드 실행을 분리하여 비동기 처리를 구현하는 동시성(Concurrency) 디자인 패턴입니다. 각 객체는 자신만의 제어 스레드를 가지며, 클라이언트의 요청을 큐에 저장한 후 스케줄러가 순차적으로 실행합니다. 클라이언트는 Future 객체를 통해 나중에 결과를 받아볼 수 있습니다.

## 문제점
1. 동기적 블로킹
    - 메서드 호출 시 완료까지 대기
    - 메인 스레드가 블로킹됨
    - 응답성 저하
2. 스레드 직접 관리의 복잡성
    - 스레드 생성/종료 관리 필요
    - 동기화 코드 작성 필요
    - 경쟁 조건 및 데드락 위험
3. 콜백 지옥
    - 중첩된 콜백으로 코드 복잡성 증가
    - 에러 처리가 어려움
    - 흐름 파악이 어려움
4. 리소스 관리
    - 무분별한 스레드 생성
    - 리소스 낭비
    - 시스템 부하 증가

## Active Object 패턴의 주요 장점
1. 비동기 실행
    - 메서드 호출 즉시 반환
    - 클라이언트가 블로킹되지 않음
    - 높은 응답성 유지
2. 스레드 안전성
    - 내부적으로 직렬화된 실행
    - 명시적 동기화 불필요
    - 경쟁 조건 방지
3. 투명한 비동기화
    - 동기 메서드처럼 사용 가능
    - 클라이언트 코드 단순화
    - Future를 통한 깔끔한 결과 처리
4. 유연한 스케줄링
    - 요청 우선순위 지정 가능
    - 동시성 수준 조절 가능
    - 취소 및 타임아웃 지원

## 주요 구성 요소
1. Proxy (프록시)
    - 클라이언트가 사용하는 공개 인터페이스
    - 메서드 호출을 MethodRequest로 변환
    - Future 객체 반환
2. Method Request (메서드 요청)
    - 메서드 호출을 객체로 캡슐화
    - 메서드 이름, 인자, Future 포함
    - Command 패턴의 변형
3. Activation Queue (활성화 큐)
    - 대기 중인 요청을 저장
    - FIFO 또는 우선순위 기반
    - 스레드 안전한 큐 사용
4. Scheduler (스케줄러)
    - 큐에서 요청을 꺼내 실행
    - 실행 정책 관리
    - 워커 스레드 풀 관리
5. Servant (서번트)
    - 실제 비즈니스 로직 수행
    - 동기적으로 작업 처리
    - 결과를 Future에 설정
6. Future (퓨처)
    - 비동기 결과를 나타내는 객체
    - 결과 대기 및 조회 가능
    - 완료 상태 확인 가능

## 구성 요소 다이어그램
```
┌─────────────┐      ┌─────────────┐      ┌─────────────────┐
│   Client    │─────▶│    Proxy    │─────▶│ Activation Queue│
└─────────────┘      └─────────────┘      └────────┬────────┘
      │                    │                       │
      │                    ▼                       ▼
      │              ┌───────────┐          ┌───────────┐
      │              │  Future   │◀─────────│ Scheduler │
      │              └───────────┘          └─────┬─────┘
      │                    ▲                      │
      │                    │                      ▼
      │                    │               ┌───────────┐
      │                    └───────────────│  Servant  │
      │                                    └───────────┘
      │
      ▼
   결과 사용
```

## Kotlin 코루틴과의 통합
1. Channel 활용
    - Activation Queue로 Channel 사용
    - 자연스러운 비동기 큐 구현
    - 백프레셔 지원
2. CompletableDeferred
    - Future 역할 수행
    - await()으로 결과 대기
    - 취소 전파 지원
3. CoroutineScope
    - 구조화된 동시성
    - 자동 취소 전파
    - 리소스 정리 용이

## 실제 활용 사례
1. GUI 프레임워크
    - UI 스레드 블로킹 방지
    - 백그라운드 작업 처리
    - 이벤트 기반 프로그래밍
2. 게임 엔진
    - 게임 객체 비동기 처리
    - AI 계산
    - 물리 시뮬레이션
3. 네트워크 서비스
    - 비동기 요청 처리
    - 연결 관리
    - 타임아웃 처리
4. 데이터베이스 접근
    - 비동기 쿼리 실행
    - 커넥션 풀 관리
    - 트랜잭션 처리

## 관련 패턴
| 패턴 | 관계 |
|------|------|
| Command | MethodRequest가 Command 패턴의 변형 |
| Future/Promise | 비동기 결과 처리에 사용 |
| Producer-Consumer | Activation Queue의 구현 기반 |
| Proxy | 클라이언트 인터페이스 제공 |
| Scheduler | 작업 실행 정책 관리 |

## 주의사항
1. 오버헤드
    - 요청 객체 생성 비용
    - 큐 관리 오버헤드
    - 단순 작업에는 부적합
2. 디버깅 어려움
    - 비동기 실행으로 흐름 추적 어려움
    - 스택 트레이스 분산
    - 로깅 중요
3. 메모리 사용
    - 요청 큐에 객체 누적 가능
    - 백프레셔 관리 필요
    - 메모리 누수 주의
4. 순서 보장
    - 기본적으로 FIFO 순서
    - 병렬 실행 시 순서 보장 안됨
    - 필요시 별도 처리 필요

## 결론
Active Object 패턴은 복잡한 동시성 프로그래밍을 단순화하는 강력한 패턴입니다. 메서드 호출과 실행을 분리하여 클라이언트에게 투명한 비동기 처리를 제공합니다. Kotlin 코루틴과 결합하면 더욱 간결하고 효율적인 비동기 시스템을 구축할 수 있습니다. GUI 애플리케이션, 게임 엔진, 네트워크 서비스 등 응답성이 중요한 시스템에서 특히 유용합니다.
