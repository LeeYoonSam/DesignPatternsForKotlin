# Service Locator 패턴

## 설명
Service Locator 패턴은 서비스의 위치 투명성을 제공하는 디자인 패턴입니다. 이 패턴은 중앙 레지스트리를 통해 서비스를 등록하고 조회할 수 있게 하여, 서비스 구현체와 클라이언트 코드 간의 결합도를 낮춥니다.

## 문제점
1. **하드코딩된 의존성**
    - 서비스 구현체가 클라이언트 코드에 직접 포함됨
    - 구현체 변경이 어려움
    - 테스트가 어려움

2. **유연성 부족**
    - 런타임에 서비스 구현체를 변경할 수 없음
    - 다양한 환경(개발, 테스트, 운영)에 따른 구현체 전환이 어려움

3. **결합도 증가**
    - 클라이언트가 특정 구현체에 강하게 결합됨
    - 코드 재사용성 감소

## Service Locator 패턴의 주요 장점
1. **위치 투명성**
    - 서비스의 실제 위치와 구현 세부사항을 숨김
    - 클라이언트는 서비스의 위치나 구현 방식을 알 필요가 없음

2. **유연한 의존성 관리**
    - 런타임에 서비스 구현체 변경 가능
    - 환경별로 다른 구현체 사용 가능

3. **테스트 용이성**
    - 목(mock) 객체로 쉽게 대체 가능
    - 단위 테스트 작성이 수월함

## 주요 구성 요소
1. **Service Interface**
    - 서비스의 계약을 정의
    - 클라이언트가 사용할 메서드 명세

2. **Service Implementation**
    - 실제 서비스 구현체
    - 다양한 구현 방식 가능

3. **Service Locator**
    - 서비스 레지스트리 역할
    - 서비스 등록 및 조회 기능 제공

## 실제 활용 사례
1. **엔터프라이즈 애플리케이션**
    - JNDI (Java Naming and Directory Interface)
    - Spring Framework의 ApplicationContext

2. **모듈식 애플리케이션**
    - 플러그인 시스템
    - 확장 가능한 아키텍처

3. **테스트 환경**
    - 테스트용 구현체 주입
    - 통합 테스트 설정

## 주의사항
1. **전역 상태 관리**
    - Service Locator가 전역 상태를 가짐
    - 멀티스레드 환경에서 주의 필요

2. **은닉된 의존성**
    - 클래스의 의존성이 명시적이지 않을 수 있음
    - 코드 이해도가 떨어질 수 있음

3. **과도한 사용 주의**
    - Dependency Injection을 완전히 대체하지 않음
    - 적절한 사용 범위 설정 필요

## 결론
Service Locator 패턴은 서비스의 위치 투명성을 제공하고 런타임에 유연한 서비스 교체를 가능하게 하는 유용한 패턴입니다. 하지만 전역 상태와 은닉된 의존성이라는 단점도 있으므로, 사용 시 이러한 트레이드오프를 고려해야 합니다. 특히 대규모 애플리케이션에서는 Dependency Injection과 함께 보완적으로 사용하는 것이 좋습니다.