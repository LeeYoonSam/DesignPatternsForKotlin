# 데코레이터 패턴 - 로깅 시스템

## 설명

데코레이터 패턴은 구조적 디자인 패턴으로, 객체에 추가 책임을 동적으로 추가할 수 있게 해줍니다. 데코레이터는 기존 객체를 수정하지 않고 기능을 확장할 수 있는 유연한 대안을 제공합니다.

## 문제점

로깅 시스템을 구현할 때 다음과 같은 문제가 발생합니다:

1. 로깅 로직이 비즈니스 로직과 혼합되어 코드가 복잡해진다.
2. 로깅 요구사항이 변경될 때마다 여러 클래스를 수정해야 한다.
3. 로깅 기능을 동적으로 추가하거나 제거하기 어렵다.
4. 성능 측정, 예외 처리, 보안 검사 등 다양한 크로스커팅 관심사를 유연하게 처리하기 어렵다.

## 데코레이터 패턴의 주요 장점

1. **단일 책임 원칙**: 각 데코레이터는 하나의 특정 기능만 담당하므로 코드가 더 명확해집니다.
2. **개방-폐쇄 원칙**: 기존 코드를 수정하지 않고 새로운 기능을 추가할 수 있습니다.
3. **유연성**: 런타임에 객체에 여러 데코레이터를 조합하여 다양한 기능을 구성할 수 있습니다.
4. **재사용성**: 데코레이터는 독립적으로 작동하므로 다른 컴포넌트에서 재사용할 수 있습니다.

## 주요 구성 요소

1. **Component**: 기본 인터페이스 또는 추상 클래스로, 데코레이터와 실제 구현체가 구현해야 하는 메서드를 정의합니다.
2. **ConcreteComponent**: Component 인터페이스를 구현한 실제 객체입니다.
3. **Decorator**: Component를 상속받고 Component 참조를 포함하는 추상 클래스입니다.
4. **ConcreteDecorator**: Decorator를 상속받고 추가 기능을 구현한 구체적인 데코레이터 클래스입니다.

## 실제 활용 사례

1. **로깅 시스템**: 비즈니스 로직에 로깅, 성능 측정, 예외 처리 등을 추가합니다.
2. **UI 컴포넌트**: 기본 UI 컴포넌트에 테두리, 스크롤바 등의 기능을 추가합니다.
3. **입출력 스트림**: Java의 InputStream, OutputStream 등에서 버퍼링, 암호화 등의 기능을 추가합니다.
4. **웹 서비스**: 인증, 캐싱, 압축 등의 기능을 HTTP 요청/응답에 추가합니다.

## 주의사항

1. **복잡성 증가**: 데코레이터가 많아지면 시스템이 복잡해질 수 있습니다.
2. **객체 생성 코드**: 여러 데코레이터를 조합할 때 객체 생성 코드가 복잡해질 수 있습니다.
3. **데코레이터 순서**: 데코레이터 적용 순서가 중요할 수 있으므로 주의해야 합니다.

## 결론

데코레이터 패턴은 객체 지향 설계의 핵심 원칙을 반영하며, 유연하고 확장 가능한 코드를 작성하는 데 큰 도움이 됩니다. 특히 로깅 시스템과 같은 크로스커팅 관심사를 처리할 때 매우 유용합니다.
