# 데코레이터 패턴 (입출력 스트림 시스템)

## 설명
데코레이터 패턴은 구조적 디자인 패턴으로, 객체에 동적으로 새로운 책임을 추가할 수 있게 합니다. 이 패턴은 상속을 통한 기능 확장의 대안으로, 기존 클래스를 수정하지 않고도 객체의 기능을 동적으로 확장할 수 있습니다. 특히 입출력 스트림과 같이 다양한 기능 조합이 필요한 경우에 효과적입니다.

## 문제점
입출력 시스템을 개발할 때 다음과 같은 문제가 발생할 수 있습니다:

1. 파일 읽기, 압축, 암호화, 버퍼링 등 다양한 기능이 필요합니다.
2. 이러한 기능들의 조합이 필요한 경우가 많습니다 (예: 압축 후 암호화된 파일 읽기).
3. 상속을 사용하면 모든 조합에 대한 클래스를 만들어야 하므로 클래스 폭발(class explosion) 문제가 발생합니다.
4. 기능을 동적으로 추가하거나 제거하기 어렵습니다.

## 데코레이터 패턴의 주요 장점

1. **단일 책임 원칙(SRP)**: 각 데코레이터는 특정 기능만 담당합니다.
2. **개방-폐쇄 원칙(OCP)**: 기존 코드를 수정하지 않고 새로운 기능을 추가할 수 있습니다.
3. **유연성**: 런타임에 객체의 동작을 동적으로 변경할 수 있습니다.
4. **다양한 조합**: 다양한 데코레이터를 조합하여 여러 기능을 함께 사용할 수 있습니다.
5. **기능 분리**: 각 기능을 별도의 클래스로 분리하여 복잡성을 줄입니다.

## 주요 구성 요소

1. **Component (구성요소)**: 데코레이터와 구체 구성요소가 구현해야 하는 인터페이스
2. **Concrete Component (구체 구성요소)**: Component 인터페이스의 기본 구현체
3. **Decorator (데코레이터)**: Component 인터페이스를 구현하고 Component 객체를 가지고 있는 추상 클래스
4. **Concrete Decorator (구체 데코레이터)**: Decorator를 상속받아 실제 기능을 추가하는 클래스

## 실제 활용 사례

1. **Java/Kotlin의 I/O 스트림**: `InputStream`, `OutputStream`, `Reader`, `Writer` 등
2. **UI 구성 요소**: GUI 라이브러리에서 위젯에 스크롤바, 테두리 등을 추가
3. **웹 서비스**: 로깅, 캐싱, 보안 등의 기능을 요청 처리 로직에 추가
4. **데이터베이스 연결**: 연결 풀링, 트랜잭션 관리 등의 기능 추가

## 주의사항

1. 데코레이터가 너무 많아지면 코드 복잡성이 증가할 수 있습니다.
2. 데코레이터 순서가 결과에 영향을 줄 수 있으므로 순서를 신중히 결정해야 합니다.
3. 데코레이터 패턴은 작은 객체를 많이 생성하므로 성능에 영향을 줄 수 있습니다.
4. 클라이언트 코드가 특정 구체 구성요소에 의존하면 데코레이터 추가가 어려울 수 있습니다.

## 결론

데코레이터 패턴은 특히 입출력 시스템과 같이 기능을 동적으로 조합해야 하는 상황에 적합합니다. 이 패턴을 사용하면 코드의 유연성과 재사용성이 향상되고, 기능을 독립적으로 개발하고 테스트할 수 있습니다. 다만, 데코레이터 계층이 깊어지면 디버깅이 어려워질 수 있으므로 적절한 균형을 유지하는 것이 중요합니다.